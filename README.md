# Leetcode-75
leet code 75


## reverse_words_in_a_string

1. 정규표현식을 이용하여 whitespace를 기준으로 문자열 내의 단어들을 분리하고 배열에 저장한다.
2. 해당 배열을 뒤집는다
3. 단어들을 하나씩 출력하고 가운데 공백을 하나씩 입력해주고, 최종적으로 앞뒤의 공백을 trim해준다.


## products_of_array_except_self

주어진 배열의 모든 수를 곱한 수를 S라 하고, 배열을 돌면서 S / num[i] 를 처리하면 됩니다. 하지만 문제에서 나눗셈 연산자를 이용하지 말라는 조건이 존재합니다.

따라서 다음과 같은 방식을 활용합니다.
* num배열에 대해 2가지 배열을 DP를 이용하여 구할 수 있습니다.
    * prefix[i] -> 0번째 수부터 i번째 수까지의 곱. prefix[i + 1] == prefix[i] * num[i] 로 O(n)에 연산 가능합니다.
    * suffix[i] -> 마지막 수부터 i번째 수 까지의 곱. 뒤부터 채워나가면서 suffix[i - 1] == suffix[i] * num[i] 로 O(n)에 연산 가능합니다.
* 자기 자신을 제외한 수의 곱은 (자기 앞의 모든 수의 곱) * (자기 뒤의 모든 수의 곱) 입니다. 
* 따라서 i번째 수를 기준으로 정답의 i번째 수인 answer[i] 는 prefix[i - 1] * suffix [i + 1] 이 됩니다.
* 위 방식은 첫번째수와 마지막 수를 제외한 모든 수에 대해 연산 가능합니다. 실제로 생각해보면 answer[0] 의 값은 suffix[1] 이고, answer[n-1] 의 값은 prefix[n-2] 입니다.
* 하지만 예외처리하기 귀찮으므로 일관성을 해치지 않는 곱셈의 항등원 1을 prefix/suffix 배열 앞뒤로 넣어주면 모든 i에 대해 answer[i] 는 prefix[i - 1] * suffix [i + 1] 를 적용할 수 있습니다. ( 1 <= i <= n )

## increasing_triplet_subsequence

i < j < k 이면서 num[i] < num[j] < num[k] 인 부분수열이 존재하는지 묻는 문제입니다. n이 50만이므로 O(n) 혹은 O(n * logN) 해법을 찾아야 합니다.

문제의 조건을 만족하는 세 수 i, j, k가 존재한다고 합시다. 다음 세 수의 조건을 가운데 수이 j 기준으로 찾아봅시다.

1. j의 입장에서 i는 자기보다 앞에와야 하며, num[i]가 자신보다 작아야합니다.
    * 배열을 앞에서부터 돌면 j가 i 보다 뒤에온다는 것은 보장할 수 있습니다. 
    * 배열을 앞에서 돌면서 최소값을 항상 저장해둡니다. 배열을 앞에서부터 돌기 때문에 num[j]가 이 최소값보다 크다면 항상 i < j 이면서 num[i] < num[j] 인 두 수 i, j 가 존재한다는 것을 알 수 있습니다.
    * 만약 num[j] 가 최소값보다 작다면, 최소값을 갱신하고 끝냅니다. 이러한 j는 세 수 i,j,k의 가운데 숫자가 될 자격이 없습니다.
    * 이러한 j가 존재한다면 이 값을 저장해둡니다.

2. k의 입장에서는 j가 자기보다 앞에와야 하며, num[j]가 자기보다 작아야 합니다. 
    * 이 조건은 1번과 동일하게 시행됩니다.
3. 추가적으로 j는 위의 1번에서 말한 j의 조건을 갖추어야 합니다.
    * 이 조건은 1번에서 j의 값을 저장해두는 방식으로 검증 가능합니다.
    * num[j]의 크기를 기록해 두었다가, num[k]가 이 값보다 크기만 하면 되므로 저장해둡니다.


결과적으로 다음 알고리즘을 탑니다. 앞에서부터 배열을 돌면서
1. 배열의 최소값보다 현재 값이 작으면 이 수는 i의 자격만 될 수 있습니다. 최소값을 갱신하고 끝냅니다.
2. 배열의 최소값보다 현재 값이 크면, 이 수는 j의 자격을 가집니다. 이러한 j가 하나라도 존재한다면 possible 변수를 true로 저장하고, num[j] 의 최소값을 기록합니다. (num[k] 는 여러 num[j] 중 가장 작은 값보다만 크면 됩니다.)
3. possible이 true 이고 (j 값이 존재하고) 현재 값이 num[j]의 최소값보다도 크면 이 수는 k 의 자격을 가집니다. 따라서 항상 true를 반환하고 함수를 종료합니다.
4. 만약 배열 전체를 순회했는데 true가 반환되지 않았으면 i,j,k 값이 없습니다. false를 반환합니다.
